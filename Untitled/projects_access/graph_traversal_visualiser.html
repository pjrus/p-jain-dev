<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Graph Traversal Visualizer (BFS & DFS)</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Basic reset and flexbox layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* background: #f5f5f5; handled by theme.css */
    }

    h1 {
      margin: 20px 0;
      font-size: 24px;
      color: #333;
    }

    /* Controls containers */
    #typeControls,
    #toolbar {
      margin-bottom: 10px;
    }

    /* Button and Select Styles */
    #typeControls button,
    #toolbar button,
    #toolbar select {
      margin-right: 8px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }

    /* Active / Selected Button State */
    #typeControls button.selected,
    #toolbar button.active {
      background: #4caf50;
      color: white;
    }

    /* Disabled State */
    #typeControls button:disabled,
    #toolbar button:disabled,
    #toolbar select:disabled {
      background: #ddd;
      color: #666;
      cursor: default;
    }

    /* Step Navigation Controls (Hidden by default) */
    #stepControls {
      margin-top: 8px;
      display: none;
    }

    #stepControls button {
      margin-right: 8px;
      padding: 5px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    #stepControls button:disabled {
      background: #ddd;
      color: #666;
      cursor: default;
    }

    #stepInfo {
      font-size: 14px;
      color: #333;
      margin-left: 12px;
    }

    /* SVG Canvas */
    svg {
      border: 1px solid #ccc;
      background: white;
      width: 800px;
      height: 500px;
      touch-action: none;
    }

    /* SVG Elements Styling */
    marker#arrow path {
      fill: #666;
    }

    .node-circle {
      fill: #2196F3;
      stroke: #1565C0;
      stroke-width: 2;
      cursor: pointer;
    }

    .node-text {
      fill: white;
      font-size: 12px;
      pointer-events: none;
    }

    /* Visual States for Nodes */
    .node-selected-1 {
      fill: #FF5722 !important;
    }

    /* First node clicked for edge */
    .node-selected-2 {
      fill: #9C27B0 !important;
    }

    /* Second node clicked for edge */
    .node-current {
      fill: #FFC107 !important;
    }

    /* Currently visited node */
    .node-final {
      fill: #4CAF50 !important;
    }

    /* Processed / Visited node */

    /* Edge Styling */
    .edge-line {
      stroke: #666;
      stroke-width: 2;
      cursor: pointer;
    }

    .edge-weight {
      fill: black;
      font-size: 12px;
      pointer-events: none;
    }

    .edge-path {
      stroke: #e91e63 !important;
      /* Highlighted tree edge */
      stroke-width: 4 !important;
    }
  </style>
</head>

<body>
  <h1>Graph Traversal Visualizer</h1>

  <!-- Graph Type Selection (Directed/Undirected) -->
  <div id="typeControls">
    <button id="undirectedBtn">Undirected</button>
    <button id="directedBtn">Directed</button>
  </div>

  <!-- Main Toolbar -->
  <div id="toolbar">
    <button id="addNodeBtn">Add Node</button>
    <button id="addEdgeBtn">Add Edge</button>
    <button id="deleteNodeBtn">Delete Node</button>
    <button id="deleteEdgeBtn">Delete Edge</button>
    <button id="generateBtn">Generate Graph</button>

    <!-- Algorithm Selection -->
    <select id="algoSelect">
      <option value="bfs">BFS</option>
      <option value="dfs">DFS</option>
    </select>

    <button id="runBtn">Run</button>
    <button id="clearBtn">Clear All</button>
  </div>

  <!-- Step Controls (visible during traversal) -->
  <div id="stepControls">
    <button id="prevBtn">◀ Prev</button>
    <button id="nextBtn">Next ▶</button>
    <button id="finishBtn">Finish</button>
    <button id="exitBtn">Exit</button>
    <span id="stepInfo"></span>
  </div>

  <!-- SVG Area -->
  <svg id="graphSvg">
    <defs>
      <!-- Arrowhead for directed edges -->
      <marker id="arrow" viewBox="0 0 10 10" refX="20" refY="5" markerUnits="strokeWidth" markerWidth="8"
        markerHeight="6" orient="auto">
        <path d="M0,0 L10,5 L0,10 z"></path>
      </marker>
    </defs>
  </svg>

  <script>
    // ===== GLOBAL DOM ELEMENTS =====
    const svg = document.getElementById('graphSvg');
    const undirectedBtn = document.getElementById('undirectedBtn');
    const directedBtn = document.getElementById('directedBtn');
    const addNodeBtn = document.getElementById('addNodeBtn');
    const addEdgeBtn = document.getElementById('addEdgeBtn');
    const deleteNodeBtn = document.getElementById('deleteNodeBtn');
    const deleteEdgeBtn = document.getElementById('deleteEdgeBtn');
    const generateBtn = document.getElementById('generateBtn');
    const algoSelect = document.getElementById('algoSelect');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const finishBtn = document.getElementById('finishBtn');
    const exitBtn = document.getElementById('exitBtn');
    const stepInfo = document.getElementById('stepInfo');
    const stepControls = document.getElementById('stepControls');

    // ===== GRAPH DATA =====
    let isDirected = false;
    let nodes = []; // { id, label, x, y, elemCircle, elemText }
    let edges = []; // { from, to, weight, elemLine, elemText }
    let nextNodeId = 0;

    // ===== INTERACTION STATE =====
    let addNodeMode = false,
      addEdgeMode = false,
      deleteNodeMode = false,
      deleteEdgeMode = false,
      edgeFirstNode = null,
      edgeSecondNode = null;

    // ===== ALGORITHM STATE =====
    let traversalSteps = [],   // Snapshots of the traversal process
      currentStepIndex = 0,
      currentAlgorithm = null;

    // ===== DRAGGING STATE =====
    let draggingNode = null,
      dragOffsetX = 0,
      dragOffsetY = 0;

    // ===== UTILITIES =====

    // Get Mouse Position in SVG Coordinates
    function getSvgPoint(evt) {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;
      return pt.matrixTransform(svg.getScreenCTM().inverse());
    }

    // Fisher-Yates Shuffle
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const r = Math.floor(Math.random() * (i + 1));
        [a[i], a[r]] = [a[r], a[i]];
      }
    }

    // ===== GRAPH TYPE SELECTION =====
    undirectedBtn.onclick = () => chooseGraphType(false);
    directedBtn.onclick = () => chooseGraphType(true);

    function chooseGraphType(dir) {
      isDirected = dir;
      undirectedBtn.classList.toggle('selected', !dir);
      directedBtn.classList.toggle('selected', dir);
      // Disable type switching if edges already exist, to avoid ambiguity
      undirectedBtn.disabled = directedBtn.disabled = edges.length > 0;
    }

    // ===== DRAWING LOGIC =====
    function drawGraph() {
      // Clear SVG content (preserve defs)
      Array.from(svg.childNodes)
        .filter(n => n.nodeName !== 'defs')
        .forEach(n => svg.removeChild(n));

      // Draw Edges
      edges.forEach((ed, i) => {
        const f = nodes.find(n => n.id === ed.from),
          t = nodes.find(n => n.id === ed.to);

        const line = document.createElementNS(svg.namespaceURI, 'line');
        line.setAttribute('x1', f.x);
        line.setAttribute('y1', f.y);
        line.setAttribute('x2', t.x);
        line.setAttribute('y2', t.y);
        line.setAttribute('class', 'edge-line');
        if (isDirected) line.setAttribute('marker-end', 'url(#arrow)');

        // Edge Click for Deletion
        line.addEventListener('click', e => {
          e.stopPropagation();
          if (deleteEdgeMode) {
            edges.splice(i, 1);
            drawGraph();
          }
        });
        svg.appendChild(line);
        ed.elemLine = line;

        // Draw Edge Weight (not strictly used in basic BFS/DFS but good for general graph)
        const midX = (f.x + t.x) / 2,
          midY = (f.y + t.y) / 2;
        const wt = document.createElementNS(svg.namespaceURI, 'text');
        wt.setAttribute('x', midX);
        wt.setAttribute('y', midY - 5);
        wt.setAttribute('class', 'edge-weight');
        wt.textContent = ed.weight;
        svg.appendChild(wt);
        ed.elemText = wt;
      });

      // Draw Nodes
      nodes.forEach(nd => {
        const c = document.createElementNS(svg.namespaceURI, 'circle');
        c.setAttribute('cx', nd.x);
        c.setAttribute('cy', nd.y);
        c.setAttribute('r', 16);
        c.setAttribute('class', 'node-circle');
        c.dataset.id = nd.id;
        svg.appendChild(c);
        nd.elemCircle = c;

        const t = document.createElementNS(svg.namespaceURI, 'text');
        t.setAttribute('x', nd.x);
        t.setAttribute('y', nd.y + 4);
        t.setAttribute('class', 'node-text');
        t.setAttribute('text-anchor', 'middle');
        t.textContent = nd.label;
        svg.appendChild(t);
        nd.elemText = t;

        // Node Interaction
        c.addEventListener('mousedown', onNodeMouseDown);
        c.addEventListener('click', e => {
          e.stopPropagation();
          if (deleteNodeMode) {
            // Delete Node & Incident Edges
            nodes = nodes.filter(x => x.id !== nd.id);
            edges = edges.filter(e2 => e2.from !== nd.id && e2.to !== nd.id);
            chooseGraphType(isDirected); // re-eval disable state
            drawGraph();
          } else {
            // Edge Creation Selection
            onNodeClickForEdge(nd.id);
          }
        });

        // Relabel on double-click
        c.addEventListener('dblclick', e => {
          e.stopPropagation();
          if (!deleteNodeMode && !addEdgeMode) {
            const nl = prompt('New label:', nd.label);
            if (nl !== null && nl.trim() !== '') {
              nd.label = nl.trim();
              drawGraph();
            }
          }
        });
      });

      // Highlight selected nodes for edge creation
      nodes.forEach(nd => {
        nd.elemCircle.classList.remove('node-selected-1', 'node-selected-2');
        if (edgeFirstNode === nd.id) nd.elemCircle.classList.add('node-selected-1');
        if (edgeSecondNode === nd.id) nd.elemCircle.classList.add('node-selected-2');
      });
    }

    // ===== TOOLBAR HANDLERS =====

    // Toggle Add Node Mode
    addNodeBtn.onclick = () => {
      addNodeMode = !addNodeMode;
      if (addNodeMode) {
        addNodeBtn.classList.add('active');
        [addEdgeBtn, deleteNodeBtn, deleteEdgeBtn].forEach(b => b.classList.remove('active'));
        addEdgeMode = deleteNodeMode = deleteEdgeMode = false;
        edgeFirstNode = edgeSecondNode = null;
        cancelTraversal();
      } else addNodeBtn.classList.remove('active');
    };

    // Add Node on SVG Click
    svg.addEventListener('mousedown', e => {
      const p = getSvgPoint(e);
      if (addNodeMode && e.target === svg) {
        nodes.push({ id: nextNodeId, label: nextNodeId.toString(), x: p.x, y: p.y });
        nextNodeId++;
        drawGraph();
      }
    });

    // Toggle Delete Node Mode
    deleteNodeBtn.onclick = () => {
      deleteNodeMode = !deleteNodeMode;
      if (deleteNodeMode) {
        deleteNodeBtn.classList.add('active');
        [addNodeBtn, addEdgeBtn, deleteEdgeBtn].forEach(b => b.classList.remove('active'));
        addNodeMode = addEdgeMode = deleteEdgeMode = false;
        edgeFirstNode = edgeSecondNode = null;
        cancelTraversal();
      } else deleteNodeBtn.classList.remove('active');
      drawGraph();
    };

    // Toggle Add Edge Mode
    addEdgeBtn.onclick = () => {
      addEdgeMode = !addEdgeMode;
      if (addEdgeMode) {
        addEdgeBtn.classList.add('active');
        [addNodeBtn, deleteNodeBtn, deleteEdgeBtn].forEach(b => b.classList.remove('active'));
        addNodeMode = deleteNodeMode = deleteEdgeMode = false;
        edgeFirstNode = edgeSecondNode = null;
        cancelTraversal();
      } else {
        addEdgeBtn.classList.remove('active');
        edgeFirstNode = edgeSecondNode = null;
      }
      drawGraph();
    };

    // Toggle Delete Edge Mode
    deleteEdgeBtn.onclick = () => {
      deleteEdgeMode = !deleteEdgeMode;
      if (deleteEdgeMode) {
        deleteEdgeBtn.classList.add('active');
        [addNodeBtn, addEdgeBtn, deleteNodeBtn].forEach(b => b.classList.remove('active'));
        addNodeMode = addEdgeMode = deleteNodeMode = false;
        edgeFirstNode = edgeSecondNode = null;
        cancelTraversal();
      } else deleteEdgeBtn.classList.remove('active');
      drawGraph();
    };

    // Generate Random Graph
    generateBtn.onclick = () => {
      const ns = prompt("Enter number of nodes:");
      const n = parseInt(ns, 10);
      if (isNaN(n) || n < 1) { alert("Invalid."); return; }

      const maxE = isDirected ? n * (n - 1) : n * (n - 1) / 2,
        minE = n - 1;
      const es = prompt(`Enter edges (${minE}–${maxE}):`);
      let m = parseInt(es, 10);
      if (isNaN(m) || m < minE || m > maxE) { alert("Invalid."); return; }

      generateGraph(n, m);
    };

    // Clear Graph
    clearBtn.onclick = () => {
      nodes = []; edges = []; nextNodeId = 0;
      [addNodeBtn, addEdgeBtn, deleteNodeBtn, deleteEdgeBtn]
        .forEach(b => b.classList.remove('active'));
      edgeFirstNode = edgeSecondNode = null;
      cancelTraversal();
      chooseGraphType(isDirected);
      drawGraph();
    };

    // Build Random Graph Logic
    function generateGraph(n, m) {
      nodes = []; edges = []; nextNodeId = 0;
      edgeFirstNode = edgeSecondNode = null;
      cancelTraversal();
      chooseGraphType(isDirected);

      const cx = 400, cy = 250, r = 200;
      for (let i = 0; i < n; i++) {
        const ang = 2 * Math.PI / n * i;
        nodes.push({
          id: nextNodeId,
          label: nextNodeId.toString(),
          x: cx + r * Math.cos(ang),
          y: cy + r * Math.sin(ang)
        });
        nextNodeId++;
      }

      // Random Spanning Tree (ensure connectivity)
      const verts = [...Array(n).keys()];
      shuffle(verts);
      for (let i = 1; i < n; i++) {
        const u = verts[i], v = verts[Math.floor(Math.random() * i)];
        edges.push({ from: v, to: u, weight: 1 });
      }

      // Add Extra Edges to reach m
      let cnt = n - 1;
      const possible = [];
      if (isDirected) {
        for (let i = 0; i < n; i++) for (let j = 0; j < n; j++) {
          if (i !== j && !edges.some(e => e.from === i && e.to === j))
            possible.push({ from: i, to: j });
        }
      } else {
        for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) {
          if (!edges.some(e => (e.from === i && e.to === j) || (e.from === j && e.to === i)))
            possible.push({ from: i, to: j });
        }
      }
      shuffle(possible);
      while (cnt < m && possible.length) {
        const e = possible.pop();
        edges.push({ from: e.from, to: e.to, weight: 1 });
        cnt++;
      }
      drawGraph();
    }

    // Handle Click for Edge Creation (Source -> Dest)
    function onNodeClickForEdge(id) {
      if (!addEdgeMode) return;
      if (edgeFirstNode === null) {
        edgeFirstNode = id; edgeSecondNode = null; drawGraph();
      }
      else if (edgeFirstNode === id && edgeSecondNode === null) {
        edgeFirstNode = null; drawGraph();
      }
      else if (edgeFirstNode !== null && edgeSecondNode === null) {
        edgeSecondNode = id; drawGraph();
        if (edgeFirstNode !== edgeSecondNode) {
          edges.push({ from: edgeFirstNode, to: edgeSecondNode, weight: 1 });
          chooseGraphType(isDirected);
        }
        edgeFirstNode = edgeSecondNode = null;
        drawGraph();
      } else {
        edgeFirstNode = id; edgeSecondNode = null; drawGraph();
      }
    }

    // ===== DRAGGING LOGIC =====
    function onNodeMouseDown(evt) {
      evt.stopPropagation();
      const id = +evt.currentTarget.dataset.id;
      const nd = nodes.find(n => n.id === id);
      if (!nd) return;
      draggingNode = nd;
      const p = getSvgPoint(evt);
      dragOffsetX = p.x - nd.x; dragOffsetY = p.y - nd.y;
      window.addEventListener('mousemove', onDrag);
      window.addEventListener('mouseup', onDragEnd);
    }
    function onDrag(evt) {
      if (!draggingNode) return;
      const p = getSvgPoint(evt);
      draggingNode.x = p.x - dragOffsetX;
      draggingNode.y = p.y - dragOffsetY;
      drawGraph();
      if (stepControls.style.display === 'block') {
        highlightStep(currentStepIndex);
      }
    }
    function onDragEnd() {
      draggingNode = null;
      window.removeEventListener('mousemove', onDrag);
      window.removeEventListener('mouseup', onDragEnd);
    }

    // ===== ALGORITHM EXECUTION =====
    runBtn.onclick = () => {
      if (!nodes.length) { alert("No nodes."); return; }
      currentAlgorithm = algoSelect.value;

      // Disable inputs during run
      algoSelect.disabled = true;
      undirectedBtn.disabled = directedBtn.disabled = true;
      runBtn.disabled = true;

      // Select Start Node by Label
      const labels = nodes.map(n => n.label).join(', ');
      const inp = prompt(`Start node label (${labels}):`);
      if (!inp) { cancelTraversal(); return; }
      const nd = nodes.find(n => n.label === inp.trim());
      if (!nd) { alert("Invalid label."); cancelTraversal(); return; }

      if (currentAlgorithm === 'bfs') prepareBFS(nd.id);
      else prepareDFS(nd.id);
    };

    // Prepare BFS
    function prepareBFS(startId) {
      // Adjacency List
      const adj = {}; nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => {
        adj[e.from].push(e.to);
        if (!isDirected) adj[e.to].push(e.from);
      });

      const visited = {}, parent = {}, queue = [];
      nodes.forEach(n => { visited[n.id] = false; parent[n.id] = null; });

      // Start
      visited[startId] = true;
      queue.push(startId);

      // Record Snapshots
      const steps = [];
      steps.push({
        visited: { ...visited },
        queue: [...queue],
        current: null,
        parent: { ...parent }
      });

      while (queue.length) {
        const u = queue.shift();
        // Snapshot: Dequeue u
        steps.push({
          visited: { ...visited },
          queue: [...queue],
          current: u,
          parent: { ...parent }
        });

        adj[u].forEach(v => {
          if (!visited[v]) {
            visited[v] = true;
            parent[v] = u;
            queue.push(v);
            // Snapshot: Enqueue neighbor v
            steps.push({
              visited: { ...visited },
              queue: [...queue],
              current: u,
              parent: { ...parent }
            });
          }
        });
      }

      traversalSteps = steps;
      currentStepIndex = 0;
      showStepControls();
      updateStepDisplay();
    }

    // Prepare DFS (Iterative)
    function prepareDFS(startId) {
      // Adjacency list
      const adj = {}; nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => {
        adj[e.from].push(e.to);
        if (!isDirected) adj[e.to].push(e.from);
      });
      // Sort neighbors for deterministic traversal
      Object.keys(adj).forEach(k => adj[k].sort((a, b) => a - b));

      const visited = {}, parent = {}, stack = [startId];
      nodes.forEach(n => { visited[n.id] = false; parent[n.id] = null; });

      const steps = [];
      // Initial Snapshot
      steps.push({
        visited: { ...visited },
        stack: [...stack],
        current: null,
        parent: { ...parent }
      });

      while (stack.length) {
        const u = stack.pop();
        // Snapshot: Pop u
        steps.push({
          visited: { ...visited },
          stack: [...stack],
          current: u,
          parent: { ...parent }
        });

        if (!visited[u]) {
          visited[u] = true;
          // Snapshot: Visit u
          steps.push({
            visited: { ...visited },
            stack: [...stack],
            current: u,
            parent: { ...parent }
          });

          // Push unvisited neighbors (reverse order for Stack)
          adj[u].slice().reverse().forEach(v => {
            if (!visited[v]) {
              parent[v] = u;
              stack.push(v);
              // Snapshot: Push v
              steps.push({
                visited: { ...visited },
                stack: [...stack],
                current: u,
                parent: { ...parent }
              });
            }
          });
        }
      }

      traversalSteps = steps;
      currentStepIndex = 0;
      showStepControls();
      updateStepDisplay();
    }

    // Reset Visualization
    function cancelTraversal() {
      traversalSteps = [];
      currentStepIndex = 0;
      stepControls.style.display = 'none';
      algoSelect.disabled = false;
      runBtn.disabled = false;
      undirectedBtn.disabled = directedBtn.disabled = edges.length > 0;

      // Clear Highlights
      nodes.forEach(n => n.elemCircle.classList.remove('node-current', 'node-final'));
      edges.forEach(e => e.elemLine.classList.remove('edge-path'));
    }

    // ===== STEP NAVIGATION =====
    prevBtn.onclick = () => { if (currentStepIndex > 0) { currentStepIndex--; updateStepDisplay(); } };
    nextBtn.onclick = () => { if (currentStepIndex < traversalSteps.length - 1) { currentStepIndex++; updateStepDisplay(); } };
    finishBtn.onclick = () => { currentStepIndex = traversalSteps.length - 1; updateStepDisplay(); };
    exitBtn.onclick = cancelTraversal;

    function showStepControls() {
      stepControls.style.display = 'inline-block';
      prevBtn.disabled = true;
      nextBtn.disabled = traversalSteps.length <= 1;
      finishBtn.disabled = traversalSteps.length <= 1;
      exitBtn.disabled = true;
    }

    function updateStepDisplay() {
      drawGraph();
      highlightStep(currentStepIndex);
      prevBtn.disabled = (currentStepIndex === 0);
      nextBtn.disabled = (currentStepIndex === traversalSteps.length - 1);
      finishBtn.disabled = (currentStepIndex === traversalSteps.length - 1);
      exitBtn.disabled = (currentStepIndex !== traversalSteps.length - 1);
    }

    // Highlight Current Step
    function highlightStep(i) {
      const snap = traversalSteps[i];
      // Reset
      nodes.forEach(n => n.elemCircle.classList.remove('node-current', 'node-final'));
      edges.forEach(e => e.elemLine.classList.remove('edge-path'));

      // Highlight Visited
      nodes.forEach(n => { if (snap.visited[n.id]) n.elemCircle.classList.add('node-final'); });
      // Highlight Current
      if (snap.current !== null) {
        const cn = nodes.find(n => n.id === snap.current);
        if (cn) cn.elemCircle.classList.add('node-current');
      }

      // Update labels with BFS distance if applicable
      nodes.forEach(n => {
        if (currentAlgorithm === 'bfs' && snap.parent[n.id] !== undefined && snap.parent[n.id] !== null) {
          let dist = 0, p = n.id;
          // Calculate distance by traceback
          while (snap.parent[p] !== null) { dist++; p = snap.parent[p]; }
          n.elemText.textContent = `${n.label}(${dist})`;
        } else if (currentAlgorithm === 'bfs' && n.id === snap.current && snap.parent[n.id] === null) {
          // Start node distance 0
          n.elemText.textContent = `${n.label}(0)`;
        } else {
          n.elemText.textContent = n.label;
        }
      });

      // Highlight Tree Edges
      Object.keys(snap.parent).forEach(childStr => {
        const child = +childStr, par = snap.parent[child];
        if (par !== null) {
          const eObj = edges.find(e => (
            (e.from === par && e.to === child) ||
            (!isDirected && e.from === child && e.to === par)
          ));
          if (eObj) eObj.elemLine.classList.add('edge-path');
        }
      });

      // Update Info Text
      if (currentAlgorithm === 'bfs') {
        stepInfo.textContent =
          `Step ${i + 1} of ${traversalSteps.length} | Queue: [${snap.queue?.join(',') || ''}]`;
      } else {
        stepInfo.textContent =
          `Step ${i + 1} of ${traversalSteps.length} | Stack: [${snap.stack?.join(',') || ''}]`;
      }
    }

    // Initial State
    drawGraph();
    chooseGraphType(false);
  </script>
  <script src="theme.js"></script>
</body>

</html>