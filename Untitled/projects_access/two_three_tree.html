<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>2-3 Tree Visualizer</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Basic Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 25px;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* background: #f5f5f5; handled by theme.css */
    }

    h1 {
      margin: 0 0 20px;
      text-align: center;
      color: #333;
    }

    /* Control Settings */
    #stepToggle {
      margin-bottom: 12px;
      font-size: 14px;
    }

    #stepToggle input {
      margin-right: 6px;
    }

    /* Manual Input Controls */
    #manualControls {
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #manualControls input[type=number] {
      width: 80px;
      padding: 4px;
      font-size: 14px;
    }

    #manualControls button {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }

    /* SVG Canvas */
    #treeSvg {
      border: 1px solid #ccc;
      background: #fafafa;
      width: 100%;
      max-width: 1200px;
      height: 400px;
    }

    /* Step Navigation */
    #stepControls {
      display: none;
      margin-top: 12px;
    }

    #stepControls button {
      padding: 5px 10px;
      font-size: 14px;
      margin-right: 8px;
      cursor: pointer;
    }

    #stepInfo {
      font-size: 14px;
      color: #333;
      vertical-align: middle;
    }

    /* Random Generation Controls */
    #randomControls {
      margin-top: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    #randomControls input[type=number] {
      width: 80px;
      padding: 4px;
    }

    #randomControls button {
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>

<body>

  <h1>2-3 Tree Visualizer</h1>

  <!-- Visualization Options -->
  <div id="stepToggle">
    <input type="checkbox" id="stepCheckbox">
    <label for="stepCheckbox">Enable step-by-step splits/removals</label>
  </div>

  <!-- Main Controls -->
  <div id="manualControls">
    <label for="keyInput">Key:</label>
    <input type="number" id="keyInput" placeholder="e.g. 42">
    <button id="insertBtn">Insert</button>
    <button id="removeBtn">Remove</button>
  </div>

  <!-- Drawing Area -->
  <svg id="treeSvg" viewBox="0 0 500 500"></svg>

  <!-- Step Controls (Hidden by Default) -->
  <div id="stepControls">
    <button id="prevStepBtn">◀ Prev</button>
    <button id="nextStepBtn">Next ▶</button>
    <button id="finishStepBtn">Finish</button>
    <span id="stepInfo"></span>
  </div>

  <!-- Randomizer -->
  <div id="randomControls">
    <label for="randomSizeInput">Random Size (1–100):</label>
    <input type="number" id="randomSizeInput" min="1" max="100" placeholder="e.g. 10">
    <button id="generateRandomBtn">Generate Random</button>
  </div>

  <script>
    // --- Constants & Layout ---
    const SVG_SIZE = 500;
    const MARG_X = 20;
    const MARG_Y = 50;
    const VSPACING = 60;
    const BASE_SPACING = 80;

    // --- State Management ---
    let keyList = [];
    let snapshots = [];
    let currentStep = 0;
    let stepping = false;
    let currentTT;   // Active TwoThreeTree instance

    // --- 2-3 Tree Classes ---

    class TwoThreeNode {
      constructor(keys = [], children = []) {
        this.keys = keys;         // Array of 1 or 2 keys
        this.children = children; // Array of 0, 2, or 3 children
      }
    }

    class TwoThreeTree {
      constructor() { this.root = null; }

      insert(key) {
        if (!this.root) {
          this.root = new TwoThreeNode([key], []);
          return;
        }
        // Recursive insert returns a 'split' node if the child split upwards
        const split = this._insertRec(this.root, key);
        if (split) {
          // If root splits, it creates a new root
          this.root = split;
        }
      }

      _insertRec(node, key) {
        // Leaf Node Case
        if (node.children.length === 0) {
          node.keys.push(key);
          node.keys.sort((a, b) => a - b);
          // If node becomes a 4-node (3 keys), it must split
          if (node.keys.length === 3) return this._split(node);
          return null; // No split needed
        }

        // Internal Node Case: Find appropriate child
        let idx = key < node.keys[0] ? 0
          : (node.keys.length === 1 || key < node.keys[1]) ? 1
            : 2;

        const split = this._insertRec(node.children[idx], key);

        // Handle child split return
        if (split) {
          recordSnapshot(`Before split at [${node.keys.join(',')} → ${split.keys[0]}]`);

          // Absorb the promoted key from the child split
          node.keys.push(split.keys[0]);
          node.keys.sort((a, b) => a - b);

          // Replace the old child with the two new children from the split
          const pos = node.children.indexOf(node.children[idx]);
          node.children.splice(pos, 1, split.children[0], split.children[1]);

          // If this node now has 3 keys (4-node), it also splits
          if (node.keys.length === 3) {
            const s2 = this._split(node);
            recordSnapshot(`After split, promoted ${s2.keys[0]}`);
            return s2;
          }
        }
        return null;
      }

      _split(node) {
        // Split a 3-key node into two nodes and promote the middle key
        const [k1, k2, k3] = node.keys;
        let left, right;
        if (node.children.length === 0) {
          left = new TwoThreeNode([k1], []);
          right = new TwoThreeNode([k3], []);
        } else {
          // Distribute children: 4 children total (since we just added a split child)
          left = new TwoThreeNode([k1], node.children.slice(0, 2));
          right = new TwoThreeNode([k3], node.children.slice(2));
        }
        // Return a temporary holder for the promoted key and new children
        return new TwoThreeNode([k2], [left, right]);
      }
    }

    // --- Helpers ---

    function cloneTree(node) {
      if (!node) return null;
      const c = new TwoThreeNode([...node.keys], []);
      node.children.forEach(ch => c.children.push(cloneTree(ch)));
      return c;
    }

    // Capture state for step-by-step
    function recordSnapshot(info = "") {
      snapshots.push({ root: cloneTree(currentTT.root), info });
    }

    // Compute Layout Post-Order
    function computePositions(root) {
      const map = new Map();
      let counter = 0;
      (function post(n, depth) {
        if (!n) return;
        if (n.children.length === 0) {
          map.set(n, { x: counter++, y: -depth });
        } else {
          n.children.forEach(ch => post(ch, depth + 1));
          const xs = n.children.map(ch => map.get(ch).x);
          map.set(n, { x: xs.reduce((a, b) => a + b, 0) / xs.length, y: -depth });
        }
      })(root, 0);
      return { map, count: counter };
    }

    // SVG Drawing Helpers
    function drawLine(svg, x1, y1, x2, y2) {
      const l = document.createElementNS(svg.namespaceURI, "line");
      l.setAttribute("x1", x1); l.setAttribute("y1", y1);
      l.setAttribute("x2", x2); l.setAttribute("y2", y2);
      l.setAttribute("stroke", "#000"); l.setAttribute("stroke-width", "1.5");
      svg.appendChild(l);
    }
    function drawRect(svg, x, y, w, h) {
      const r = document.createElementNS(svg.namespaceURI, "rect");
      r.setAttribute("x", x); r.setAttribute("y", y);
      r.setAttribute("width", w); r.setAttribute("height", h);
      r.setAttribute("fill", "lavender");
      r.setAttribute("stroke", "#000"); r.setAttribute("rx", "4");
      svg.appendChild(r);
    }
    function drawText(svg, text, x, y, color = "#000", size = 12) {
      const t = document.createElementNS(svg.namespaceURI, "text");
      t.setAttribute("x", x); t.setAttribute("y", y);
      t.setAttribute("fill", color);
      t.setAttribute("font-size", size);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("dominant-baseline", "middle");
      t.textContent = text;
      svg.appendChild(t);
    }

    // --- Main Redraw Function ---
    function redraw() {
      const svg = document.getElementById("treeSvg");
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      let root = currentTT.root;
      if (stepping && snapshots.length) {
        root = snapshots[currentStep].root;
      }

      const { map, count } = computePositions(root);
      if (count === 0) {
        drawText(svg, "2-3 Tree", SVG_SIZE / 2, MARG_Y / 2, "#333", 16);
        return;
      }

      // Base spacing bump if any 3-key nodes exist to prevent overlap
      let has3 = false;
      for (let n of map.keys()) if (n.keys.length === 3) { has3 = true; break; }
      const base = has3 ? BASE_SPACING * 1.5 : BASE_SPACING;

      // Measure span for centering
      const xs = Array.from(map.values()).map(p => p.x);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const span = maxX - minX + 1;

      // Count nodes on each depth (for improved spacing calc)
      const depthCount = {};
      map.forEach((p, _) => {
        const d = -p.y;
        depthCount[d] = (depthCount[d] || 0) + 1;
      });
      const maxCount = Math.max(...Object.values(depthCount));

      // Effective spacing
      const eff = base + 0.1 * (maxCount - 1);
      const shift = (SVG_SIZE / 2) - ((span / 2) * eff + MARG_X);

      // Draw Edges
      map.forEach((pos, node) => {
        const cx = MARG_X + (pos.x - minX + 0.5) * eff + shift;
        const cy = MARG_Y + (-pos.y) * VSPACING;
        node.children.forEach(ch => {
          const p2 = map.get(ch);
          const x2 = MARG_X + (p2.x - minX + 0.5) * eff + shift;
          const y2 = MARG_Y + (-p2.y) * VSPACING;
          drawLine(svg, cx, cy, x2, y2);
        });
      });

      // Draw Nodes
      map.forEach((pos, node) => {
        const cx = MARG_X + (pos.x - minX + 0.5) * eff + shift;
        const cy = MARG_Y + (-pos.y) * VSPACING;
        const w = node.keys.length * 30 + 20; // Width depends on number of keys
        const x0 = cx - w / 2, y0 = cy - 15;

        drawRect(svg, x0, y0, w, 30);

        if (node.keys.length === 1) {
          drawText(svg, String(node.keys[0]), cx, cy + 2);
        } else if (node.keys.length === 2) {
          // Draw separator
          drawLine(svg, cx, y0, cx, y0 + 30);
          drawText(svg, String(node.keys[0]), cx - w / 4, cy + 2);
          drawText(svg, String(node.keys[1]), cx + w / 4, cy + 2);
        } else {
          // Temporary 3-node visualization during split
          const t3 = w / 3;
          drawLine(svg, x0 + t3, y0, x0 + t3, y0 + 30);
          drawLine(svg, x0 + 2 * t3, y0, x0 + 2 * t3, y0 + 30);
          drawText(svg, String(node.keys[0]), x0 + t3 / 2, cy + 2);
          drawText(svg, String(node.keys[1]), x0 + w / 2, cy + 2);
          drawText(svg, String(node.keys[2]), x0 + w - t3 / 2, cy + 2);
        }
      });

      drawText(svg, "2-3 Tree", SVG_SIZE / 2, MARG_Y / 2, "#333", 16);
    }

    // --- Step Control Logic ---
    function updateStepInfo() {
      const info = document.getElementById("stepInfo");
      const snap = snapshots[currentStep];
      info.textContent = `Step ${currentStep + 1} of ${snapshots.length}: ${snap.info}`;
      document.getElementById("prevStepBtn").disabled = currentStep === 0;
      document.getElementById("nextStepBtn").disabled = currentStep === snapshots.length - 1;
    }

    document.getElementById("prevStepBtn").onclick = () => {
      if (currentStep > 0) { currentStep--; redraw(); updateStepInfo(); }
    };

    document.getElementById("nextStepBtn").onclick = () => {
      if (currentStep < snapshots.length - 1) {
        currentStep++;
        if (currentStep === snapshots.length - 1) {
          // Auto-exit step mode on last step
          stepping = false;
          document.getElementById("stepControls").style.display = "none";
          redraw();
        } else {
          redraw(); updateStepInfo();
        }
      }
    };

    document.getElementById("finishStepBtn").onclick = () => {
      stepping = false;
      document.getElementById("stepControls").style.display = "none";
      redraw();
    };

    document.getElementById("stepCheckbox").onchange = () => {
      if (!document.getElementById("stepCheckbox").checked && stepping) {
        stepping = false; snapshots = []; currentStep = 0;
        document.getElementById("stepControls").style.display = "none";
        redraw();
      }
    };

    // --- Insert / Remove Handlers ---
    document.getElementById("insertBtn").onclick = () => {
      const v = parseInt(document.getElementById("keyInput").value, 10);
      if (!isNaN(v) && !keyList.includes(v)) {
        const stepOn = document.getElementById("stepCheckbox").checked;
        snapshots = []; currentStep = 0; stepping = false;

        // Setup initial clean state logic for recording
        // To record splits, we'll hook into _split method mostly.

        // Rebuild current tree from scratch to ensure clean slate?
        // Or just continue? We'll continue, but we need to track snapshot logic.

        // Simplest strategy for visualized steps: 
        // 1. Replay previous insertions to get clean state
        // 2. Insert new value with hooks

        // Rebuild base for stability
        currentTT = new TwoThreeTree();
        keyList.forEach(k => currentTT.insert(k)); // Restore previous

        if (!stepOn) {
          // Direct Insert
          keyList.push(v); keyList.sort((a, b) => a - b);
          currentTT = new TwoThreeTree(); keyList.forEach(k => currentTT.insert(k));
          redraw(); return;
        }

        // Stepped Insert
        const orig = currentTT._split.bind(currentTT);

        // Hook Split to record snapshots
        currentTT._split = node => {
          recordSnapshot(`Split [${node.keys.join(',')},...]`);
          const r = orig(node);
          recordSnapshot(`Promote ${r.keys[0]}`);
          return r;
        };

        currentTT.insert(v);
        currentTT._split = orig; // Restore

        if (!snapshots.length) {
          // No splits occurred
          keyList.push(v); keyList.sort((a, b) => a - b);
          currentTT = new TwoThreeTree(); keyList.forEach(k => currentTT.insert(k));
          redraw(); return;
        }

        // Committing the change to keyList so next op continues correctly
        keyList.push(v); keyList.sort((a, b) => a - b);

        stepping = true;
        document.getElementById("stepControls").style.display = "block";
        updateStepInfo(); redraw();
      }
      document.getElementById("keyInput").value = ""; document.getElementById("keyInput").focus();
    };

    document.getElementById("removeBtn").onclick = () => {
      const v = parseInt(document.getElementById("keyInput").value, 10);
      if (!isNaN(v) && keyList.includes(v)) {
        const stepOn = document.getElementById("stepCheckbox").checked;
        snapshots = []; currentStep = 0; stepping = false;

        // Restore
        currentTT = new TwoThreeTree(); keyList.forEach(k => currentTT.insert(k));

        if (!stepOn) {
          keyList = keyList.filter(k => k !== v);
          currentTT = new TwoThreeTree(); keyList.forEach(k => currentTT.insert(k));
          redraw(); return;
        }

        // For removal visualization, standard implementation is complex.
        // We'll just snapshot "Before" and "After" for now.
        recordSnapshot("Before removal");
        keyList = keyList.filter(k => k !== v);
        currentTT = new TwoThreeTree(); keyList.forEach(k => currentTT.insert(k));
        recordSnapshot("After removal");

        stepping = true;
        document.getElementById("stepControls").style.display = "block";
        updateStepInfo(); redraw();
      }
      document.getElementById("keyInput").value = ""; document.getElementById("keyInput").focus();
    };

    // --- Random Generator ---
    document.getElementById("generateRandomBtn").onclick = () => {
      const n = parseInt(document.getElementById("randomSizeInput").value, 10);
      if (isNaN(n) || n < 1 || n > 100) { alert("Enter 1–100"); return; }

      const was = document.getElementById("stepCheckbox").checked;
      document.getElementById("stepCheckbox").checked = false; // Disable stepping for bulk
      stepping = false;
      document.getElementById("stepControls").style.display = "none";

      let arr = Array.from({ length: 100 }, (_, i) => i + 1);
      // Shuffle
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      keyList = arr.slice(0, n);

      currentTT = new TwoThreeTree();
      keyList.forEach(k => currentTT.insert(k));

      document.getElementById("stepCheckbox").checked = was; // Restore setting
      redraw();
    };

    // --- Initialization ---
    window.onload = () => {
      currentTT = new TwoThreeTree();
      redraw();
    };
  </script>
  <script src="theme.js"></script>
</body>

</html>