<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Compressed Suffix-Trie Visualizer</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Basic reset and flexbox layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* background-color: #f5f5f5; handled by theme.css */
    }

    h1 {
      margin-bottom: 10px;
    }

    /* Control Groups */
    #buildControls,
    #compressControls,
    #stepControls {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
    }

    /* Input & Button Styling */
    #buildControls input {
      font-size: 16px;
      padding: 4px;
      width: 300px;
      margin-right: 8px;
    }

    #buildControls button,
    #compressControls button {
      font-size: 16px;
      padding: 6px 12px;
      margin-right: 8px;
      cursor: pointer;
    }

    /* Compression Controls */
    #compressControls label {
      display: flex;
      align-items: center;
      margin-right: 8px;
      font-size: 16px;
    }

    /* Step Controls (Hidden by default) */
    #stepControls {
      display: none;
    }

    #stepControls button {
      font-size: 14px;
      padding: 5px 10px;
      margin-right: 8px;
      cursor: pointer;
    }

    #stepInfo {
      font-size: 14px;
      color: #333;
    }

    /* SVG Container */
    #svgContainer {
      width: 800px;
      height: 500px;
      border: 1px solid #ccc;
      background: #fafafa;
      overflow: auto;
    }

    svg {
      display: block;
    }

    /* Node & Edge Styling */
    .edge {
      stroke: #888;
      stroke-width: 1.5px;
    }

    .node-circle {
      fill: #8f8;
      stroke: #333;
      stroke-width: 2px;
    }

    .node-term {
      fill: #fc0;
      stroke: #333;
      stroke-width: 2px;
    }

    .node-text {
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
      fill: #000;
      pointer-events: none;
    }

    /* Highlight class for merging nodes during compression */
    .node-highlight {
      fill: yellow !important;
      stroke: #333;
      stroke-width: 2px;
    }
  </style>
</head>

<body>
  <h1>Compressed Suffix-Trie Visualizer</h1>

  <!-- Inputs for Building Trie -->
  <div id="buildControls">
    <input id="strInput" placeholder="Enter text (e.g. banana)" />
    <button id="buildBtn">Build Trie</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- Compression Controls -->
  <div id="compressControls">
    <label><input type="checkbox" id="stepCheckbox" /> Step-by-step</label>
    <button id="compressBtn">Compress</button>
  </div>

  <!-- Step Navigation (Visible only during step-by-step compression) -->
  <div id="stepControls">
    <button id="prevStepBtn">◀ Prev</button>
    <button id="nextStepBtn">Next ▶</button>
    <button id="finishStepBtn">Finish</button>
    <span id="stepInfo"></span>
  </div>

  <!-- Visualization Area -->
  <div id="svgContainer">
    <svg id="svgCanvas" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <script>
    const NS = "http://www.w3.org/2000/svg";
    // Layout Constants
    const BASE_R = 15, H_GAP = 100, V_GAP = 80, PADDING = 20;

    // --- Trie Node Class ---
    class TrieNode {
      constructor(label = "") {
        this.label = label;
        this.children = {};
        this.isTerminal = false;
        this.x = 0; this.y = 0;
        this.id = TrieNode.nextId++; // Unique ID for tracking in snapshots
      }
    }
    TrieNode.nextId = 1;

    // --- Global State ---
    const root = new TrieNode();
    let snapshots = [], currentStep = 0, inStepMode = false;

    // --- Operations ---
    function clearTrie() {
      TrieNode.nextId = 1;
      root.label = ""; root.children = {}; root.isTerminal = false; root.id = TrieNode.nextId++;
    }

    // Insert a single suffix
    function insertWord(w) {
      let n = root;
      for (let ch of w) {
        if (!n.children[ch]) n.children[ch] = new TrieNode(ch);
        let c = n.children[ch];

        // Split node if it has a multi-char label (shouldn't happen in standard uncompressed insert, 
        // but handles mixed state if re-inserting into compressed)
        if (c.label.length > 1) {
          const rest = c.label.slice(1);
          c.label = ch;
          const g = new TrieNode(rest);
          g.children = c.children; g.isTerminal = c.isTerminal;
          c.children = { [rest[0]]: g };
          c.isTerminal = false;
        }
        n = c;
      }
      n.isTerminal = true;
    }

    // Build the initial uncompressed suffix trie
    function buildSuffixTrie(s) {
      clearTrie();
      // Insert every suffix
      for (let i = 0; i < s.length; i++) insertWord(s.slice(i) + "$");
      insertWord("$"); // Separate terminal for empty suffix case if needed, or explicitly part of others
      inStepMode = false; hideStepControls(); render();
    }

    // Deep clone for snapshots
    function cloneNode(n) {
      const c = new TrieNode(n.label);
      c.id = n.id;                      // preserve original ID to match highlights
      c.isTerminal = n.isTerminal;
      for (let k in n.children)
        c.children[k] = cloneNode(n.children[k]);
      return c;
    }

    // Capture state for step-by-step visualization
    function capture(desc, highlights = []) {
      if (!document.getElementById("stepCheckbox").checked) return;
      snapshots.push({
        root: cloneNode(root),
        desc,
        highlights: highlights.slice()
      });
    }

    // Compress the Trie (merge single-child nodes)
    function compressTrie() {
      snapshots = [];
      capture("Start compression", []);

      (function dfs(node, parentKey, parent) {
        // Post-order traversal to compress from bottom up
        for (let key of Object.keys(node.children)) {
          dfs(node.children[key], key, node);
          // Re-fetch keys as they might change during merge
        }

        // Merge logic: If node is not terminal and has exactly one child (and not root-ish special case)
        const keys = Object.keys(node.children);
        if (!node.isTerminal && keys.length === 1) {
          // For visualization, we keep '$' terminal logic usually separate, but here we merge if single child
          if (keys[0] !== "$") {
            const child = node.children[keys[0]];
            // Snapshot before merge actions
            capture(
              `Merge "${node.label}" + "${child.label}"`,
              [node.id, child.id]
            );

            // Perform Merge
            const merged = node.label + child.label;
            node.label = merged;
            node.isTerminal = child.isTerminal;
            node.children = child.children;

            // No need to update parent's child reference because 'node' object is mutated in place.
            // However, if we needed to replace 'node' itself, we'd use parentKey.
          }
        }
      })(root, null, null);

      capture("End compression", []);

      // Init Step Mode if enabled
      if (snapshots.length && document.getElementById("stepCheckbox").checked) {
        currentStep = 0; inStepMode = true; showStepControls();
      } else {
        inStepMode = false; hideStepControls();
      }
      render();
    }

    // Layout: Compute Subtree Sizes
    function computeSizes(n) {
      n._size = 0;
      for (let c of Object.values(n.children)) {
        computeSizes(c);
        n._size += c._size;
      }
      if (n.isTerminal) n._size++;
      if (!n._size) n._size = 1;
    }

    // Layout: Assign X,Y Positions
    function assignPos(n, depth = 0, xOff = 0) {
      const kids = [...Object.values(n.children)];
      // If terminal, conceptually has a child (leaf)
      // Visualizer treats terminal flag as a state, but leaves need space
      if (!kids.length) {
        n.x = xOff; n.y = depth; return xOff + 1;
      }

      let cur = xOff, xs = [];
      for (let c of kids) {
        cur = assignPos(c, depth + 1, cur);
        xs.push(c.x);
      }
      // Center parent
      n.x = (Math.min(...xs) + Math.max(...xs)) / 2;
      n.y = depth;
      return cur;
    }

    // --- Rendering ---
    function render() {
      const svg = document.getElementById("svgCanvas");
      svg.innerHTML = "";

      // Select tree source
      const tree = inStepMode ? snapshots[currentStep].root : root;
      const highlights = inStepMode ? snapshots[currentStep].highlights : [];

      // Calculate Layout
      computeSizes(tree);
      assignPos(tree);

      // Determine Bounding Box
      const pts = [];
      (function collect(n) {
        pts.push({ x: n.x, y: n.y });
        for (let c of Object.values(n.children)) collect(c);
      })(tree);

      let minX = 0, maxX = 0, minY = 0, maxY = 0;
      if (pts.length) {
        const xs = pts.map(p => p.x), ys = pts.map(p => p.y);
        minX = Math.min(...xs); maxX = Math.max(...xs);
        minY = Math.min(...ys); maxY = Math.max(...ys);
      }

      const contentW = (maxX - minX) * H_GAP + PADDING * 2;
      const contentH = (maxY - minY) * V_GAP + PADDING * 2;
      const svgW = Math.max(contentW, 800);
      const svgH = Math.max(contentH, 500);

      svg.setAttribute("width", svgW);
      svg.setAttribute("height", svgH);

      // Center in View
      const containerW = document.getElementById("svgContainer").clientWidth;
      const offX = contentW <= containerW
        ? containerW / 2 - tree.x * H_GAP
        : PADDING - minX * H_GAP;
      const offY = PADDING - minY * V_GAP;

      const g = create("g", { transform: `translate(${offX},${offY})` });
      svg.appendChild(g);

      // Draw Edges
      (function drawE(n) {
        // Dynamic radius based on label length
        const rN = BASE_R + 4 * ((n.isTerminal ? "$" : n.label).length - 1);
        for (let c of Object.values(n.children)) {
          const rC = BASE_R + 4 * ((c.isTerminal ? "$" : c.label).length - 1);
          g.appendChild(create("line", {
            x1: n.x * H_GAP, y1: n.y * V_GAP + rN,
            x2: c.x * H_GAP, y2: c.y * V_GAP - rC,
            class: "edge"
          }));
          drawE(c);
        }
      })(tree);

      // Draw Nodes
      (function drawN(n) {
        const lbl = n.isTerminal ? (n.label || "$") : n.label; // Show label, or $ if empty terminal
        const effectiveLbl = n.isTerminal && n.label ? n.label + "$" : (n.label || "$");
        // Actually typically suffix trie nodes just show edge labels, but here nodes contain the string part
        // Let's stick to existing logic: n.label is shown in node.

        // Determine radius
        const r = BASE_R + 4 * (n.label.length - 1 > 0 ? n.label.length - 1 : 0);

        let cls = n.isTerminal ? "node-term" : "node-circle";
        if (highlights.includes(n.id)) cls = "node-highlight";

        g.appendChild(create("circle", { cx: n.x * H_GAP, cy: n.y * V_GAP, r, class: cls }));

        const txt = create("text", { x: n.x * H_GAP, y: n.y * V_GAP, class: "node-text" });
        txt.textContent = n.label || "root";
        g.appendChild(txt);

        for (let c of Object.values(n.children)) drawN(c);
      })(tree);

      if (inStepMode) {
        document.getElementById("stepInfo").textContent =
          `Step ${currentStep + 1}/${snapshots.length}: ${snapshots[currentStep].desc}`;
      }
    }

    // Helper to create SVG elements
    function create(tag, attrs) {
      const e = document.createElementNS(NS, tag);
      for (let k in attrs) e.setAttribute(k, attrs[k]);
      return e;
    }

    // Step Control Visibility
    function showStepControls() { document.getElementById("stepControls").style.display = "flex"; }
    function hideStepControls() { document.getElementById("stepControls").style.display = "none"; }

    // --- Interaction ---
    document.getElementById("buildBtn").onclick =
      () => buildSuffixTrie(document.getElementById("strInput").value);

    document.getElementById("clearBtn").onclick =
      () => { clearTrie(); inStepMode = false; hideStepControls(); render(); };

    document.getElementById("compressBtn").onclick = compressTrie;

    // Step Navigation Handlers
    document.getElementById("prevStepBtn").onclick =
      () => { if (currentStep > 0) currentStep--; render(); };

    document.getElementById("nextStepBtn").onclick =
      () => {
        if (currentStep < snapshots.length - 1) currentStep++;
        else { inStepMode = false; hideStepControls(); }
        render();
      };

    document.getElementById("finishStepBtn").onclick =
      () => { inStepMode = false; hideStepControls(); render(); };

    // Initial Render
    render();
  </script>
  <script src="theme.js"></script>
</body>

</html>