<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AVL Tree Visualizer with Step-by-Step Insert & Delete</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Basic page reset and layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 25px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      margin-top: 20px;
      text-align: center;
    }

    /* Step toggle control styling */
    #stepToggle {
      margin-bottom: 12px;
      font-size: 14px;
    }

    #stepToggle input {
      margin-right: 6px;
    }

    /* Container for manual and random controls */
    #manualControls,
    #randomControls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      align-items: center;
      margin: 10px 0;
    }

    /* Input and button styling */
    #manualControls input,
    #randomControls input {
      width: 80px;
      font-size: 16px;
      padding: 2px 4px;
    }

    #manualControls button,
    #randomControls button {
      font-size: 16px;
      padding: 6px 12px;
    }

    .note {
      margin-left: 20px;
      font-size: 14px;
      color: #555;
    }

    /* SVG visualization area */
    #avlSvg {
      border: 1px solid #ccc;
      background: #fafafa;
      width: 100%;
      height: 500px;
    }

    /* Responsive adjustment for smaller screens */
    @media (max-width:600px) {
      #avlSvg {
        height: 300px;
      }
    }

    /* Step navigation controls (hidden by default) */
    #stepControls {
      display: none;
      margin-top: 15px;
    }

    #stepControls button {
      font-size: 14px;
      padding: 5px 10px;
      margin-right: 8px;
    }

    #stepInfo {
      font-size: 14px;
      margin-left: 12px;
      color: #333;
    }
  </style>
</head>

<body>
  <h1>AVL Tree Visualizer</h1>

  <!-- Checkbox to enable step-by-step visualization -->
  <div id="stepToggle">
    <input type="checkbox" id="stepCheckbox" />
    <label for="stepCheckbox">Enable step-by-step</label>
  </div>

  <!-- Manual insertion and removal controls -->
  <div id="manualControls">
    <label for="keyInput">Key:</label>
    <input type="number" id="keyInput" placeholder="e.g. 42" />
    <button id="insertBtn">Insert</button>
    <button id="removeBtn">Remove</button>
    <span class="note">Unique integer keys</span>
  </div>

  <!-- SVG Container for the tree -->
  <svg id="avlSvg" viewBox="0 0 500 500"></svg>

  <!-- Controls for navigating through steps -->
  <div id="stepControls">
    <button id="prevStepBtn">◀ Prev</button>
    <button id="nextStepBtn">Next ▶</button>
    <button id="finishStepBtn">Finish</button>
    <span id="stepInfo"></span>
  </div>

  <!-- Controls for generating random trees -->
  <div id="randomControls">
    <label for="randomSizeInput">Random Size:</label>
    <input type="number" id="randomSizeInput" min="1" max="100" placeholder="e.g. 10" />
    <button id="generateRandomBtn">Generate</button>
  </div>

  <script>
    // Global state for stepping through visualizations
    let currentStep = 0, inSteppingMode = false;

    // Show the step navigation controls
    function showStepControls() {
      document.getElementById('stepControls').style.display = 'block';
      updateStepInfo();
    }

    // Hide the step navigation controls
    function hideStepControls() {
      document.getElementById('stepControls').style.display = 'none';
    }

    // Update the step information text and button states
    function updateStepInfo() {
      const snap = avl.snapshots[currentStep];
      const info = document.getElementById('stepInfo');
      info.textContent = `Step ${currentStep + 1} of ${avl.snapshots.length}: ${snap.rotationType}`;
      document.getElementById('prevStepBtn').disabled = (currentStep === 0);
      document.getElementById('nextStepBtn').disabled = (currentStep === avl.snapshots.length - 1);
    }

    /**
     * Class representing a node in the AVL Tree
     */
    class AVLNode {
      constructor(key) {
        this.key = key;
        this.left = null;
        this.right = null;
        this.height = 1; // Height of the node for balancing
      }
    }

    /**
     * Helper to deep clone a tree structure
     * used for capturing snapshots
     */
    function cloneTree(node) {
      if (!node) return null;
      const copy = new AVLNode(node.key);
      copy.height = node.height;
      copy.left = cloneTree(node.left);
      copy.right = cloneTree(node.right);
      return copy;
    }

    /**
     * AVL Tree implementation with snapshot capabilities for visualization
     */
    class AVLTree {
      constructor() {
        this.root = null;
        this.snapshots = []; // Stores tree states for step-by-step view
        this.stepEnabled = false;
      }

      // Capture the current state of the tree
      capture(label, nodeKey = null, pivotKey = null) {
        if (!this.stepEnabled) return;
        this.snapshots.push({
          root: cloneTree(this.root),
          nodeKey, pivotKey,
          rotationType: label
        });
      }

      // Insert a key into the AVL tree
      insert(key) {
        this.stepEnabled = document.getElementById('stepCheckbox').checked;
        this.snapshots = [];
        this.capture(`Begin insert ${key}`);
        this.root = this._insertRec(this.root, key);
        this.capture(`End insert ${key}`);
        this._finalizeSteps();
      }

      // Recursive helper for insertion
      _insertRec(node, key) {
        // Standard BST insertion
        if (!node) return new AVLNode(key);
        if (key < node.key) node.left = this._insertRec(node.left, key);
        else if (key > node.key) node.right = this._insertRec(node.right, key);
        else return node; // Duplicate keys not allowed

        // Update height
        node.height = 1 + Math.max(this._height(node.left), this._height(node.right));

        // Rebalance the node if necessary
        return this._rebalance(node);
      }

      // Remove a key from the AVL tree
      remove(key) {
        this.stepEnabled = document.getElementById('stepCheckbox').checked;
        this.snapshots = [];
        this.capture(`Begin delete ${key}`);
        this.root = this._deleteRec(this.root, key);
        this.capture(`End delete ${key}`);
        this._finalizeSteps();
      }

      // Recursive helper for deletion
      _deleteRec(node, key) {
        if (!node) return null;

        // Standard BST deletion
        if (key < node.key) {
          node.left = this._deleteRec(node.left, key);
        }
        else if (key > node.key) {
          node.right = this._deleteRec(node.right, key);
        }
        else {
          // Node found
          // zero children
          if (!node.left && !node.right) {
            this.capture(`Remove leaf ${node.key}`, node.key);
            return null;
          }
          // one child
          if (!node.left) {
            this.capture(`Link ${node.key} → right child ${node.right.key}`, node.key, node.right.key);
            return node.right;
          }
          if (!node.right) {
            this.capture(`Link ${node.key} → left child ${node.left.key}`, node.key, node.left.key);
            return node.left;
          }
          // two children: promote successor (min of right subtree)
          const succ = this._min(node.right);
          this.capture(`Promote ${succ.key} to replace ${node.key}`, succ.key, node.key);
          node.key = succ.key;
          node.right = this._deleteRec(node.right, succ.key);
          // standalone promotion step
          this.capture(`After promotion of ${succ.key}`, succ.key);
        }

        // Update height
        node.height = 1 + Math.max(this._height(node.left), this._height(node.right));

        // Rebalance
        return this._rebalance(node);
      }

      // Find the node with minimum key
      _min(n) {
        while (n.left) n = n.left;
        return n;
      }

      // Helper to get node height
      _height(n) { return n ? n.height : 0; }

      // Get balance factor of a node
      _getBalance(n) { return n ? this._height(n.left) - this._height(n.right) : 0; }

      // Rebalance a node if it becomes unbalanced
      _rebalance(node) {
        const b = this._getBalance(node);

        // Left Heavy (LL or LR)
        if (b > 1) {
          if (this._getBalance(node.left) >= 0) {
            // Left Left Case
            this.capture(`Right rotation at ${node.key}`, node.key, node.left.key);
            node = this._rotateRight(node);
          } else {
            // Left Right Case
            this.capture(`LR inner (${node.key}): left rotate ${node.left.key}`, node.left.key, node.left.right?.key);
            node.left = this._rotateLeft(node.left);
            this.capture(`After LR inner`, node.left.key);
            this.capture(`LR outer (${node.key}): right rotate ${node.key}`, node.key, node.left.key);
            node = this._rotateRight(node);
          }
        }
        // Right Heavy (RR or RL)
        if (b < -1) {
          if (this._getBalance(node.right) <= 0) {
            // Right Right Case
            this.capture(`Left rotation at ${node.key}`, node.key, node.right.key);
            node = this._rotateLeft(node);
          } else {
            // Right Left Case
            this.capture(`RL inner (${node.key}): right rotate ${node.right.key}`, node.right.key, node.right.left?.key);
            node.right = this._rotateRight(node.right);
            this.capture(`After RL inner`, node.right.key);
            this.capture(`RL outer (${node.key}): left rotate ${node.key}`, node.key, node.right.key);
            node = this._rotateLeft(node);
          }
        }
        return node;
      }

      // Perform Right Rotation
      _rotateRight(y) {
        const x = y.left, T2 = x.right;
        x.right = y; y.left = T2;
        y.height = 1 + Math.max(this._height(y.left), this._height(y.right));
        x.height = 1 + Math.max(this._height(x.left), this._height(x.right));
        if (this.root === y) this.root = x;
        return x;
      }

      // Perform Left Rotation
      _rotateLeft(x) {
        const y = x.right, T2 = y.left;
        y.left = x; x.right = T2;
        x.height = 1 + Math.max(this._height(x.left), this._height(x.right));
        y.height = 1 + Math.max(this._height(y.left), this._height(y.right));
        if (this.root === x) this.root = y;
        return y;
      }

      // Prepare UI for stepping mode if changes occurred
      _finalizeSteps() {
        if (this.stepEnabled && this.snapshots.length) {
          currentStep = 0;
          inSteppingMode = true;
          redraw();
          showStepControls();
        } else {
          inSteppingMode = false;
          hideStepControls();
          redraw();
        }
      }
    }

    // --- Layout & specific logic for drawing the tree --- //

    // Compute x,y coordinates for each node
    function computeAVLPositions(root) {
      const map = new Map(), ctr = [0];
      // In-order traversal to assign x coordinates
      (function io(n, d) {
        if (!n) return;
        io(n.left, d + 1);
        map.set(n, { x: ctr[0]++, y: -d });
        io(n.right, d + 1);
      })(root, 0);
      return { map, count: ctr[0] };
    }

    // Constants for SVG drawing
    const SVG_SIZE = 500, M_Y = 50, V_SP = 60, H_SP = 80;

    // Main draw function
    function redraw() {
      const svg = document.getElementById('avlSvg');
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      let root = avl.root, hlN = null, hlP = null;
      // If stepping, use the snapshot root and highlight keys
      if (inSteppingMode && avl.snapshots.length) {
        const s = avl.snapshots[currentStep];
        root = s.root; hlN = s.nodeKey; hlP = s.pivotKey;
      }

      // Compute positions
      const { map: pm, count } = computeAVLPositions(root);
      if (count > 0) {
        const xs = [...pm.values()].map(p => p.x);
        const mn = Math.min(...xs), mx = Math.max(...xs);
        const units = mx - mn + 1;
        // base spacing calculation
        let spacing = (units * H_SP > SVG_SIZE ? SVG_SIZE / units : H_SP);
        // dynamic scaling factor based on tree size
        let factor = 1;
        if (count >= 30) { factor += 0.15 * (Math.floor((count - 35) / 10) + 1); }
        spacing *= factor;
        const px = new Map();
        pm.forEach((p, n) => px.set(n, (p.x - mn + 0.5) * spacing));
        const shift = SVG_SIZE / 2 - px.get(root);

        // draw edges first
        pm.forEach((p, n) => {
          const x0 = px.get(n) + shift, y0 = M_Y + (-p.y) * V_SP;
          if (n.left) {
            const q = pm.get(n.left);
            drawLine(svg, x0, y0, px.get(n.left) + shift, M_Y + (-q.y) * V_SP);
          }
          if (n.right) {
            const q = pm.get(n.right);
            drawLine(svg, x0, y0, px.get(n.right) + shift, M_Y + (-q.y) * V_SP);
          }
        });
        // draw nodes on top
        pm.forEach((p, n) => {
          const cx = px.get(n) + shift, cy = M_Y + (-p.y) * V_SP;
          let fill = 'white';
          if (n.key === hlN) fill = 'lightcoral'; // Highlight node
          else if (n.key === hlP) fill = 'lightblue'; // Highlight pivot
          drawCircle(svg, cx, cy, 15, fill);
          drawText(svg, n.key.toString(), cx, cy + 2);
        });
      }
      drawText(svg, 'AVL Tree', SVG_SIZE / 2, M_Y / 2, '#333', 16);
    }

    // SVG helper functions
    function drawCircle(svg, x, y, r, fill) {
      const c = createSVG('circle', { cx: x, cy: y, r, fill, stroke: 'black', 'stroke-width': 2 });
      svg.appendChild(c);
    }
    function drawLine(svg, x1, y1, x2, y2) {
      const l = createSVG('line', { x1, y1, x2, y2, stroke: '#000', 'stroke-width': 1.5 });
      svg.appendChild(l);
    }
    function drawText(svg, t, x, y, fill = '#000', size = 12) {
      const e = createSVG('text', { x, y, fill, 'font-size': size, 'text-anchor': 'middle', 'dominant-baseline': 'middle' });
      e.textContent = t;
      svg.appendChild(e);
    }
    function createSVG(tag, attrs) {
      const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (let k in attrs) e.setAttribute(k, attrs[k]);
      return e;
    }

    // --- Initialization and Event Listeners --- //

    // Instantiate AVL Tree
    const avl = new AVLTree();

    // Event listeners for manually adding/removing nodes
    document.getElementById('insertBtn').addEventListener('click', () => {
      const v = parseInt(document.getElementById('keyInput').value, 10);
      if (!isNaN(v)) avl.insert(v);
      document.getElementById('keyInput').value = '';
    });
    document.getElementById('removeBtn').addEventListener('click', () => {
      const v = parseInt(document.getElementById('keyInput').value, 10);
      if (!isNaN(v)) avl.remove(v);
      document.getElementById('keyInput').value = '';
    });

    // Generate a random tree
    document.getElementById('generateRandomBtn').addEventListener('click', () => {
      const n = parseInt(document.getElementById('randomSizeInput').value, 10);
      if (isNaN(n) || n < 1 || n > 100) { alert('Enter 1–100'); return; }

      // Shuffle 1..100 to get unique randoms
      const arr = Array.from({ length: 100 }, (_, i) => i + 1);
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }

      // Temporarily disable stepping for bulk insert
      const was = document.getElementById('stepCheckbox').checked;
      document.getElementById('stepCheckbox').checked = false;
      inSteppingMode = false; hideStepControls();

      avl.root = null; avl.snapshots = [];
      arr.slice(0, n).forEach(k => avl.root = avl._insertRec(avl.root, k));

      document.getElementById('stepCheckbox').checked = was;
      redraw();
    });

    // Step navigation listeners
    document.getElementById('prevStepBtn').addEventListener('click', () => {
      if (currentStep > 0) { currentStep--; redraw(); updateStepInfo(); }
    });
    document.getElementById('nextStepBtn').addEventListener('click', () => {
      if (currentStep < avl.snapshots.length - 1) {
        currentStep++;
        if (currentStep === avl.snapshots.length - 1) {
          inSteppingMode = false; hideStepControls(); redraw();
        } else { redraw(); updateStepInfo(); }
      }
    });
    document.getElementById('finishStepBtn').addEventListener('click', () => {
      inSteppingMode = false; hideStepControls(); redraw();
    });
    document.getElementById('stepCheckbox').addEventListener('change', () => {
      if (!document.getElementById('stepCheckbox').checked && inSteppingMode) {
        inSteppingMode = false; hideStepControls(); redraw();
      }
    });

    window.onload = () => { redraw(); };
  </script>
  <script src="theme.js"></script>
</body>

</html>