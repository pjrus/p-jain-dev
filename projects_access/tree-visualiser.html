<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Left-Leaning Red-Black Tree Visualizer</title>
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Basic Styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* theme-handled background */
    }

    h1 {
      margin-top: 20px;
    }

    /* Control sections */
    #stepToggle {
      margin: 10px 0;
      font-size: 14px;
    }

    #controls {
      margin: 10px 0;
    }

    #controls input {
      width: 80px;
      font-size: 16px;
      padding: 2px;
      margin-right: 10px;
    }

    #controls button {
      font-size: 16px;
      padding: 6px 12px;
      margin-right: 10px;
      cursor: pointer;
    }

    /* Step Navigation Controls (Hidden unless enabled) */
    #stepControls {
      display: none;
      margin: 10px 0;
      font-size: 14px;
    }

    #stepControls button {
      font-size: 14px;
      padding: 5px 10px;
      margin-right: 8px;
      cursor: pointer;
    }

    #stepInfo {
      margin-left: 12px;
      color: #333;
    }

    /* SVG container */
    #rbtSvg {
      width: 100%;
      max-width: 700px;
      height: 500px;
      border: 1px solid #ccc;
      background: #fafafa;
    }

    /* Responsive adjustment */
    @media (max-width: 600px) {
      #rbtSvg {
        height: 300px;
      }
    }
  </style>
</head>

<body>

  <h1>Left-Leaning Red-Black Tree</h1>

  <!-- Toggle for Step-by-Step Visualization -->
  <div id="stepToggle">
    <input type="checkbox" id="stepCheckbox" />
    <label for="stepCheckbox">Enable step-by-step rotations</label>
  </div>

  <!-- Key Operations -->
  <div id="controls">
    <label for="keyInput">Key:</label>
    <input type="number" id="keyInput" placeholder="e.g. 15" />
    <button id="insertBtn">Insert</button>
    <button id="removeBtn">Remove</button>
  </div>

  <!-- Stepping Controls -->
  <div id="stepControls">
    <button id="prevStepBtn">◀ Prev</button>
    <button id="nextStepBtn">Next ▶</button>
    <button id="finishStepBtn">Finish</button>
    <span id="stepInfo"></span>
  </div>

  <!-- SVG Visualization Area -->
  <div id="treesContainer">
    <svg id="rbtSvg" viewBox="0 0 500 500"></svg>
  </div>

  <script>
    // ───── RBT Classes ───────────────────────────────────────

    /**
     * Node structure for Left-Leaning Red-Black Tree
     */
    class RBTNode {
      constructor(key, color = 'red') {
        this.key = key;
        this.color = color; // 'red' or 'black'
        this.left = null;
        this.right = null;
      }
    }

    /**
     * Standard LLRB Tree Implementation
     * Based on Sedgewick's implementation logic
     */
    class LeftLeaningRB {
      constructor() {
        this.root = null;
      }

      // Check if node is red
      _isRed(node) {
        return node?.color === 'red';
      }

      // Left Rotation: Fixes right-leaning red links
      _rotateLeft(h) {
        const x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = 'red';
        return x;
      }

      // Right Rotation: Fixes two consecutive left-leaning red links
      _rotateRight(h) {
        const x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        h.color = 'red';
        return x;
      }

      // Color Flip: Splits a 4-node
      _flipColors(h) {
        h.color = h.color === 'red' ? 'black' : 'red';
        if (h.left) h.left.color = h.left.color === 'red' ? 'black' : 'red';
        if (h.right) h.right.color = h.right.color === 'red' ? 'black' : 'red';
      }

      // Public Insert Method
      insert(key) {
        this.root = this._put(this.root, key);
        if (this.root) this.root.color = 'black'; // Root is always black
      }

      // Recursive Insert Helper
      _put(h, key) {
        if (!h) return new RBTNode(key, 'red'); // Insert as red

        // On the way down, split 4-nodes (in 2-3-4 tree mapping)?
        // Standard LLRB splits 4-nodes on the way UP usually, but 'Top-Down' 2-3-4 does it down.
        // This implementation seems to mix standard Sedgewick LLRB logic.

        // Standard LLRB puts color flip check after traversal, 
        // effectively splitting 4-nodes on the way up.

        if (key < h.key) {
          h.left = this._put(h.left, key);
        } else if (key > h.key) {
          h.right = this._put(h.right, key);
        }

        // Fix-up operations on the way back up (Post-order)

        // 1. Right child red, left black -> Rotate Left
        if (this._isRed(h.right) && !this._isRed(h.left)) {
          h = this._rotateLeft(h);
        }
        // 2. Left child red, Left-Left grandchild red -> Rotate Right
        if (this._isRed(h.left) && this._isRed(h.left.left)) {
          h = this._rotateRight(h);
        }
        // 3. Both children red -> Flip Colors
        if (this._isRed(h.left) && this._isRed(h.right)) {
          this._flipColors(h);
        }

        return h;
      }
    }

    // ───── Globals ───────────────────────────────────────────

    let keyList = [];
    let rbTree = new LeftLeaningRB();

    // For Step-by-Step Visualization
    let snapshots = [];
    let currentStep = 0;
    let stepping = false;

    // Layout Constants
    const SVG_SIZE = 500;
    const MARG_X = 20;
    const MARG_Y = 50;
    const VSPACING = 60;
    const HSPACING = 80;

    // ───── SVG Helpers ───────────────────────────────────────

    function createSVG(tag, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
      return el;
    }

    function drawCircle(svg, cx, cy, r, fill, stroke) {
      svg.appendChild(createSVG('circle', {
        cx, cy, r, fill, stroke, 'stroke-width': 2
      }));
    }

    function drawLine(svg, x1, y1, x2, y2, color = '#000', width = 1) {
      svg.appendChild(createSVG('line', {
        x1, y1, x2, y2,
        stroke: color,
        'stroke-width': width,
        'marker-end': 'url(#arrow)'
      }));
    }

    function drawText(svg, text, x, y, color, fontSize = 12) {
      const t = createSVG('text', {
        x, y, fill: color,
        'font-size': fontSize,
        'text-anchor': 'middle',
        'dominant-baseline': 'middle',
        'font-family': 'Arial'
      });
      t.textContent = text;
      svg.appendChild(t);
    }

    function addArrowMarker(svg) {
      if (svg.querySelector('defs')) return;
      const defs = createSVG('defs', {});
      const marker = createSVG('marker', {
        id: 'arrow',
        markerWidth: 10,
        markerHeight: 7,
        refX: 10,
        refY: 3.5,
        orient: 'auto'
      });
      marker.appendChild(createSVG('polygon', {
        points: '0 0,10 3.5,0 7',
        fill: '#000'
      }));
      defs.appendChild(marker);
      svg.appendChild(defs);
    }

    // ───── Compute Positions (In-Order Traversal) ────────────

    function computeRBTPositions(root) {
      const map = new Map();
      const ctr = [0];

      (function inOrder(node, depth) {
        if (!node) return;
        inOrder(node.left, depth + 1);
        map.set(node, { x: ctr[0]++, y: depth });
        inOrder(node.right, depth + 1);
      })(root, 0);

      return { map, count: ctr[0] };
    }

    // ───── Redraw Logic ──────────────────────────────────────

    function redrawTrees() {
      const svg = document.getElementById('rbtSvg');
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      addArrowMarker(svg);

      let rootToDraw, posData;

      // Determine what to draw (Current Snapshot vs Live Tree)
      if (stepping && snapshots.length) {
        rootToDraw = snapshots[currentStep].rbt;
        posData = snapshots[currentStep].pos; // Use pre-calculated positions to stabilize animation
      } else {
        rootToDraw = rbTree.root;
        posData = computeRBTPositions(rootToDraw);
      }

      const xs = Array.from(posData.map.values()).map(p => p.x);
      if (xs.length) {
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const span = maxX - minX + 1;
        const pixelSpan = span * HSPACING;
        const avail = SVG_SIZE - 2 * MARG_X;
        // Scale down if tree is too wide
        const scale = pixelSpan > avail ? avail / pixelSpan : 1;
        const eff = HSPACING * scale;

        // Center alignment
        const center = MARG_X + (span / 2) * eff;
        const shift = (SVG_SIZE / 2) - center;

        // Draw Edges First
        posData.map.forEach((p, node) => {
          ['left', 'right'].forEach(dir => {
            const child = node[dir];
            if (child) {
              const c = posData.map.get(child);
              const x0 = MARG_X + (p.x - minX + 0.5) * eff + shift;
              const y0 = MARG_Y + p.y * VSPACING;
              const x1 = MARG_X + (c.x - minX + 0.5) * eff + shift;
              const y1 = MARG_Y + c.y * VSPACING;
              // Red links are drawn red
              drawLine(svg, x0, y0, x1, y1, child.color === 'red' ? 'red' : 'black');
            }
          });
        });

        // Draw Nodes
        posData.map.forEach((p, node) => {
          const cx = MARG_X + (p.x - minX + 0.5) * eff + shift;
          const cy = MARG_Y + p.y * VSPACING;
          drawCircle(svg, cx, cy, 15, node.color === 'red' ? 'red' : 'black', 'white');
          drawText(svg, node.key.toString(), cx, cy, 'white', 12);
        });
      }

      // Title
      drawText(svg, 'LLRB Tree', SVG_SIZE / 2, MARG_Y / 2, '#333', 16);
    }

    // ───── Snapshot Logic for Step-by-Step ───────────────────

    function cloneRBT(node) {
      if (!node) return null;
      const clone = new RBTNode(node.key, node.color);
      clone.left = cloneRBT(node.left);
      clone.right = cloneRBT(node.right);
      return clone;
    }

    // ───── Insertion with Snapshots ──────────────────────────

    // Helper to capture state after rotation/flip
    function fixUp(node) {
      let changed = false;
      // 1. Rotate Left
      if (node.right?.color === 'red' && node.left?.color !== 'red') {
        node = rbTree._rotateLeft(node);
        // Snapshot
        snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
      }
      // 2. Rotate Right
      if (node.left?.color === 'red' && node.left.left?.color === 'red') {
        node = rbTree._rotateRight(node);
        snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
      }
      // 3. Flip Colors
      if (node.left?.color === 'red' && node.right?.color === 'red') {
        rbTree._flipColors(node);
        snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
      }
      return node;
    }

    // Simulated Insert that records snapshots
    // Note: We are mocking the recursion stack iteratively or reconstructing it 
    // to capture snapshots 'during' the process is tricky in pure recursion without 
    // passing the whole tree copy.
    // The strategy here: use a path stack to simulate the post-order fix-up.
    function bstInsert(val) {
      snapshots = [];
      currentStep = 0;
      stepping = false;
      hideStepControls();

      // Empty Tree Case
      if (!rbTree.root) {
        rbTree.root = new RBTNode(val, 'red');
        snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
        rbTree.root.color = 'black';
        redrawTrees();
        return;
      }

      // 1. Standard BST Insert (Iterative to track path)
      const path = [];
      let n = rbTree.root;

      // Note: This simplified step-by-step logic might slightly differ from recursive structure 
      // if we don't mirror the 4-node splitting exactly as the class does. 
      // For visual purposes, we follow the path.

      while (n) {
        // Color flip on way down (Top-Down 2-3-4 splitting style)? 
        // Or standard LLRB? The class _put does color flip at END (Post-order).
        // Let's stick to post-order fixup.

        path.push(n);
        if (val < n.key) {
          if (!n.left) {
            n.left = new RBTNode(val, 'red');
            snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
            break;
          }
          n = n.left;
        } else {
          if (!n.right) {
            n.right = new RBTNode(val, 'red');
            snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });
            break;
          }
          n = n.right;
        }
      }

      // 2. Backtrack to fix-up (Post-order)
      // We need to re-link the tree as we go up because rotations change structure.
      // This is complex iteratively.

      // RE-IMPLEMENTATION: We can't easily execute "half" a recursion in JS to snapshot.
      // PROXY APPROACH: We will actually modify the real tree, and just snapshot whenever a structural change occurs.
      // But `fixUp` needs to update the parent's reference to `node`.

      // We will iterate backwards through path.
      for (let i = path.length - 1; i >= 0; i--) {
        let node = path[i];

        // Check current state of 'node' in the real tree (it might have been rotated by its children processing?)
        // Actually, we process children first. `node` is the parent. 
        // The child reference `node.left` or `node.right` might have changed if we processed child in previous iter.

        // Wait, standard `_put` returns the new `h`.
        // So we need to emulate that: `fixed` becomes the new child for `path[i-1]`.

        let fixed = fixUp(node); // This applies rotations and pushes snapshots

        // Update linkage
        if (i === 0) {
          rbTree.root = fixed;
        } else {
          const p = path[i - 1];
          // Determine which child `node` was (using Key comparison since structure defines it)
          // But wait, key comparison might fail if rotations moved things?
          // Actually, `node` was pushed to path. `p` is its parent.

          if (p.left === node) p.left = fixed; // Link new subtree root
          else p.right = fixed;
        }

        // Update the path array for next iteration? 
        // No, `path[i]` is done. `path[i-1]` will be processed next being the parent.
        // `path[i-1]` might need to know its child changed. We just did that.
      }

      rbTree.root.color = 'black';
      snapshots.push({ rbt: cloneRBT(rbTree.root), pos: computeRBTPositions(rbTree.root) });

      stepping = true;
      showStepControls();
      redrawTrees();
    }

    // ───── UI Handlers ───────────────────────────────────────

    document.getElementById('insertBtn').onclick = () => {
      const v = parseInt(document.getElementById('keyInput').value, 10);
      if (isNaN(v) || keyList.includes(v)) return; // No duplicates for simplicity
      keyList.push(v);

      if (!document.getElementById('stepCheckbox').checked) {
        rbTree.insert(v);
        redrawTrees();
      } else {
        bstInsert(v);
      }

      document.getElementById('keyInput').value = '';
      document.getElementById('keyInput').focus();
    };

    document.getElementById('removeBtn').onclick = () => {
      const v = parseInt(document.getElementById('keyInput').value, 10);
      if (isNaN(v)) return;

      const idx = keyList.indexOf(v);
      if (idx === -1) return;

      // Remove from list and rebuild tree (Deletion in LLRB is complex to implement step-by-step from scratch here)
      keyList.splice(idx, 1);

      // Reset state
      snapshots = [];
      stepping = false;
      currentStep = 0;
      hideStepControls();

      // Rebuild
      rbTree = new LeftLeaningRB();
      keyList.forEach(k => rbTree.insert(k));

      redrawTrees();
      document.getElementById('keyInput').value = '';
      document.getElementById('keyInput').focus();
    };

    // Step Controls
    document.getElementById('prevStepBtn').onclick = () => {
      if (currentStep > 0) {
        currentStep--;
        redrawTrees();
        updateStepInfo();
      }
    };

    document.getElementById('nextStepBtn').onclick = () => {
      if (currentStep < snapshots.length - 1) {
        currentStep++;
        redrawTrees();
        updateStepInfo();
        // Finsh state
        if (currentStep === snapshots.length - 1) {
          stepping = false;
          hideStepControls();
        }
      }
    };

    document.getElementById('finishStepBtn').onclick = () => {
      stepping = false;
      hideStepControls();
      redrawTrees();
    };

    document.getElementById('stepCheckbox').onchange = () => {
      // If unchecking while active, cancel steps
      if (!document.getElementById('stepCheckbox').checked && stepping) {
        stepping = false;
        hideStepControls();
        redrawTrees();
      }
    };

    function updateStepInfo() {
      document.getElementById('stepInfo').textContent =
        `Step ${currentStep + 1} of ${snapshots.length}`;
      document.getElementById('prevStepBtn').disabled = (currentStep === 0);
      document.getElementById('nextStepBtn').disabled = (currentStep === snapshots.length - 1);
    }

    function showStepControls() {
      document.getElementById('stepControls').style.display = 'block';
      updateStepInfo();
    }

    function hideStepControls() {
      document.getElementById('stepControls').style.display = 'none';
    }

    window.onload = () => {
      redrawTrees();
    };
  </script>
  <script src="theme.js"></script>
</body>

</html>